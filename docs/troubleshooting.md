# 웹 프론트엔드 트러블슈팅 기록 (Web Troubleshooting)

이 문서는 `web` 모듈 개발 중 발생한 문제와 기술적 해결책을 기록합니다.

---

## 1. Docker 환경에서의 Radix UI 모듈 인식 오류

### 문제 상황

Docker 환경에서 `next dev` 실행 시, `package.json`에 명시된 `@radix-ui/react-alert-dialog`, `@radix-ui/react-tabs` 등의 모듈을 찾을 수 없다는 `Module not found` 에러가 발생하며 빌드가 중단되었습니다. 로컬 환경에서는 정상 작동하나 컨테이너 내부의 `node_modules`에만 특정 패키지가 누락되는 현상이 반복되었습니다.

### 원인

1. **볼륨 마운트 충돌**: 로컬의 `node_modules`와 컨테이너 내의 `node_modules`가 도커 익명 볼륨 설정에 의해 꼬일 수 있음.
2. **Lockfile 불일치**: `package-lock.json`의 변경 사항이 컨테이너 빌드 시점에 완전히 반영되지 않거나 캐시된 이미지를 사용하여 구버전 의존성이 유지됨.

### 해결책

1. **수동 모듈 주입**: 가동 중인 컨테이너 내에서 `docker exec`를 통해 누락된 패키지를 강제로 재설치하여 런타임 오류를 즉시 해결.
   - `docker exec sugang-helper-web npm install @radix-ui/react-alert-dialog @radix-ui/react-tabs`
2. **의존성 잠금 동기화**: 로컬에서 `npm install`을 새로 수행하여 `package-lock.json`을 갱신하고, 이를 Docker 빌드 시 `npm ci` 과정에서 사용하도록 구성.
3. **볼륨 대피(Exclusion)**: `docker-compose.yml`에서 `/app/node_modules`를 익명 볼륨으로 처리하여 컨테이너 내의 패키지가 로컬 환경에 덮어씌워지지 않도록 설정.

### 결과

모든 UI 컴포넌트(`Alert`, `Tabs`, `Switch` 등)가 Turbopack 환경에서 정상적으로 컴파일되고 렌더링됨을 확인했습니다.

---

## 2. API 응답 필드 불일치 (Course/Subscription)

### 문제 상황

백엔드에서 내려오는 데이터 필드명(예: `professor`)과 프론트엔트 인터페이스(`professorName`)가 일치하지 않아 데이터가 `NaN`으로 표시되거나 목록이 비어 보이는 현상이 발생했습니다.

### 해결책

- **규격 통일**: 자체 정의한 **OpenAPI v0** 사양을 기준으로 백엔드 DTO와 프론트엔드 `types/api.ts`를 전면 재매핑했습니다.
- **주요 수정**: `totalSeats`, `currentSeats`, `availableSeats`, `professorName` 등으로 모든 필드명을 표준화했습니다.

### 결과

검색 결과 및 구독 목록에서 강의명, 교수명, 수강 인원 현황이 정확하게 노출됩니다.

---

## 3. 초기 검색 상태 오인 및 로딩 피드백 부재

### 문제 상황

1. **초기 상태 오인**: 검색 페이지 진입 시 검색 조건이 비어있어(`{}`) 아무런 데이터가 뜨지 않았고, 사용자는 이를 "버튼이 동작하지 않음"으로 오인했습니다.
2. **피드백 부재**: 검색 버튼 클릭 시 로딩 표시가 없어 네트워크 지연 시 사용자가 중복 클릭하거나 멈춘 것으로 판단했습니다.

### 해결책

1. **기본값 설정**: `SearchPage`의 초기 상태를 `2026-1학기`로 설정하여 진입 즉시 데이터가 노출되도록 수정했습니다.
2. **스켈레톤 UI 도입**: 데이터 로딩 중 빈 화면 대신 테이블 형태의 **Skeleton Loader**를 보여주어 로딩 중임을 명확히 인지시켰습니다.
3. **버튼 상태 관리**: API 요청 중에는 검색 버튼 내부에 스피너를 표시하고 클릭을 방지(`disabled`)했습니다.

### 결과

사용자가 페이지 진입 시점부터 검색 완료 시점까지 끊김 없는(Seamless) 경험을 하게 되었으며, "고장"이라는 오인을 원천 차단했습니다.

### 4. 테이블 헤더 고정 (Sticky Header) 이슈

- **문제**: `shadcn/ui`의 `Table` 컴포넌트 사용 시, 내부적으로 감싸고 있는 `div`의 `overflow-x-auto` 속성 때문에 `sticky` 포지셔닝이 스크롤 컨테이너 기준이 아닌 내부 div 기준으로 잡혀 헤더가 고정되지 않는 현상 발생.
- **해결**: `CourseTable` 컴포넌트에서 `Table` 래퍼 컴포넌트 대신 표준 HTML `table` 태그를 직접 사용하고, 외부 스크롤 컨테이너(`max-h-[650px]`)에 맞춰 `sticky`가 동작하도록 구조를 변경함.

---

## 5. 검색 경험(UX) 최적화: 조건부 필터 및 자동 접힘

### 문제 상황

1. 상세 검색 필터의 항목이 많아져 실제 검색 결과 리스트가 화면 하단으로 밀려나 가독성이 저하되었습니다.
2. 교양 관련 검색 필터가 전공 검색 시에도 노출되어 혼란을 야기했습니다.

### 해결책

1. **조건부 렌더링**: 이수구분이 '교양'인 경우에만 교양 상세 카테고리 필터가 애니메이션과 함께 나타나도록 수정했습니다.
2. **자동 접힘(Auto-Collapse)**: 검색 버튼을 누르거나 엔터 키를 입력하여 검색이 시작되면 자동적으로 `Collapsible` 필터바가 닫히도록 로직을 추가하여 결과 화면이 즉시 상단에 노출되도록 했습니다.

### 결과

모바일 및 데스크톱 환경 모두에서 화면 공간을 효율적으로 사용하게 되었으며, 사용자의 검색 흐름(Flow)이 비약적으로 매끄러워졌습니다.

---

## 6. 서비스 워커 무한 로딩 및 타임아웃 처리

### 문제 상황

웹푸시 기기 등록 시, `navigator.serviceWorker.ready`가 promise 상태에서 영원히 대기하여 UI가 무한 로딩("등록 중...") 상태에 빠지는 현상이 간헐적으로 발생했습니다.

### 원인

서비스 워커 등록이 어떤 이유로 지연되거나 이미 등록된 워커가 비정상 상태일 때, ready 속성이 resolve 되지 않는 경우가 있었습니다.

### 해결책

- **Time-out 도입**: `Promise.race`를 사용하여 서비스 워커 준비에 5초의 타임아웃을 걸었습니다.
- **Fail-safe**: 5초 내에 응답이 없으면 명확한 에러를 발생시키고 UI 로딩을 해제하여 사용자가 재시도를 할 수 있도록 유도했습니다.

```typescript
// webpush.ts
const registration = await Promise.race([
  navigator.serviceWorker.ready,
  new Promise((_, reject) =>
    setTimeout(() => reject(new Error("Timeout")), 5000),
  ),
]);
```

### 결과

무한 대기 상황이 사라지고, 사용자에게 즉각적인 피드백(성공/실패)을 제공하게 되었습니다.

---

## 7. Web Push VAPID 키 환경 변수 연동

### 문제 상황

웹푸시 구독(`pushManager.subscribe`) 시점에 `applicationServerKey`가 유효하지 않다는 에러가 발생하거나 구독 객체가 `null`로 반환되었습니다.

### 원인

Next.js 환경에서 클라이언트 사이드 코드(브라우저)는 `NEXT_PUBLIC_` 접두사가 붙은 환경 변수만 접근할 수 있는데, `.env` 파일에 접두사 없이 정의하거나 `process.env` 접근이 누락되어 키 값이 `undefined`로 전달되었습니다.

### 해결책

- **변수명 변경**: `.env` 파일의 변수명을 `NEXT_PUBLIC_VAPID_KEY`로 수정했습니다.
- **유효성 검사**: `webpush.ts` 유틸리티에서 키가 존재하는지 검사하는 방어 코드를 추가하여, 키 누락 시 명확한 에러 메시지를 던지도록 수정했습니다.

### 결과

서버와 동일한 공개 키를 사용하여 VAPID 핸드셰이크가 정상적으로 이루어지게 되었습니다.

---

## 8. 포그라운드 알림 미표시 (이중 알림 구조)

### 문제 상황

브라우저 탭을 보고 있는 상태(Foreground)에서는 OS 정책이나 브라우저 설정에 따라 시스템 푸시 알림이 뜨지 않아, 사용자가 중요 알림을 놓칠 가능성이 있었습니다.

### 해결책

서비스 워커와 클라이언트 간의 **양방향 통신(Message Passing)**을 활용한 이중 알림 구조를 구축했습니다.

1. **Service Worker**: 푸시 수신 시 `showNotification`을 호출함과 동시에, 열려 있는 모든 Window Client에게 `postMessage`로 푸시 내용을 전송합니다.
2. **Client**: `navigator.serviceWorker`의 메시지 이벤트를 리스닝하고 있다가, 푸시 메시지가 오면 **`sonner` Toast**를 화면 상단에 띄웁니다.
3. **UX 강화**: `requireInteraction: true` 옵션을 추가하여 사용자가 닫기 전까지 시스템 알림이 유지되도록 설정했습니다.

### 결과

## 사용자가 다른 작업을 하거나 탭을 보고 있을 때 등 모든 시나리오에서 알림을 확실히 인지할 수 있게 되었습니다.

## 9. API 요청 중복 제거 (Request Deduplication) 및 프로미스 캐싱

### 문제 상황

로그인 후 또는 페이지 진입 시 `/api/v1/users/me` API가 짧은 간격으로 2번 이상 호출되는 현상이 발생했습니다. 이는 React Strict Mode의 영향과 더불어, Zustand의 세션 체크와 React Query의 데이터 페칭이 각각 독립적으로 발생하며 네트워크 자원을 낭비하는 결과를 초래했습니다.

### 해결책

API 레이어(`lib/api/user.ts`)에서 **Promise Caching** 패턴을 도입하여 짧은 시간 내 발생하는 동일 요청을 하나로 묶었습니다.

```typescript
let profilePromise: Promise<CommonResponse<User>> | null = null;

export const getMyProfile = async () => {
  if (profilePromise) return profilePromise; // 가고 있는 기차가 있으면 그 티켓을 같이 씀

  profilePromise = (async () => {
    try {
      const { data } = await api.get("/api/v1/users/me");
      return data;
    } finally {
      setTimeout(() => {
        profilePromise = null;
      }, 100); // 처리 완료 후 캐시 해제
    }
  })();
  return profilePromise;
};
```

### 결과

서로 다른 상태 관리 도구(Zustand, React Query)가 동일한 API를 호출하더라도 실제 네트워크 요청은 단 1회만 발생하게 되어 초기 로딩 성능이 개선되고 서버 부하를 줄였습니다.

---

---

## 10. BFF 환경에서의 자동 토큰 리프레시 인터셉터 도입

### 문제 상황

BFF 아키텍처 전환 이후 세션 쿠키를 사용함에도 불구하고, 내부적으로 관리되는 JWT 액세스 토큰이 만료되면 401 Unauthorized 에러가 발생하여 사용자가 로그아웃되는 현상이 남아있었습니다. 기존에는 단순히 로그인 페이지로 리다이렉트했으나, 이는 사용자의 작업 흐름을 끊는 요인이 되었습니다.

### 해결책

Axios 인터셉터를 고도화하여 **투명한 토큰 리프레시(Transparent Token Refresh)** 메커니즘을 구현했습니다.

1. **401 감지**: API 호출 시 401 에러가 발생하면 인터셉터가 이를 가로챕니다.
2. **자동 리프레시**: 백그라운드에서 `/api/auth/refresh`를 호출하여 서버 사이드 세션과 토큰을 갱신합니다.
3. **요청 재시도**: 리프레시 성공 시 기존의 `failedQueue`에 담겨있던 요청들을 새로운 세션 상태로 자동 재시도합니다.
4. **무한 루프 방지**: `_retry` 플래그와 `isRefreshing` 상태를 활용하여 리프레시 요청 자체가 무한 반복되는 것을 원천 차단했습니다.

### 결과

사용자는 서비스 이용 중 별도의 재로그인 과정 없이도 장시간 안정적인 인증 상태를 유지할 수 있게 되었습니다.

---

## 12. 프리미엄 대시보드 Bento Grid 도입 및 레이아웃 최적화

### 문제 상황

기존 대시보드는 여러 독립된 섹션(시간표, 관심 강의, 알림)이 단순히 나열되어 있어 시각적 집중도가 떨어지고, 특히 모바일/작은 해상도에서 정보 과다로 인한 피로도가 높았습니다.

### 해결책

1. **Bento Grid 시스템**: 현대적이고 세련된 그리드 레이아웃을 적용하여 정보의 우선순위에 따라 구획을 나눴습니다.
2. **레이아웃 간소화 (Layout Simplification)**: 사용자가 가장 핵심적인 정보인 '시간표'에 집중할 수 있도록, 기존 우측 컬럼의 '관심 강의'와 '실시간 알림' 목록을 상세 목록 형태에서 제외하고 `DashboardStats` 위젯으로 요약 정보만 상단에 노출했습니다.
3. **영역 확장**: 목록 섹션이 제거된 공간에 '대표 시간표' 섹션을 전면(Full-width)으로 확장하여 시각적 몰입감을 극대화했습니다.

### 결과

불필요한 데이터 로딩과 UI 요소를 줄임으로써 대시보드 진입 속도가 향상되었으며, 사용자는 가장 중요한 주간 일정을 더 크고 명확하게 확인할 수 있게 되었습니다.

---

## 13. 401 인터셉터 정교화 (Promise Queueing & Retry Logic)

### 문제 상황

BFF 환경에서 여러 API가 동시에 호출되는 중 액세스 토큰이 만료될 경우, 각 요청마다 독립적으로 401 에러를 받고 여러 번의 리프레시 시도가 발생하거나, 리프레시 도중 발생한 요청들이 유실되는 현상이 발견되었습니다.

### 해결책

Axios 인터셉터에 **요청 큐(Request Queue)** 메커니즘을 도입하여 리프레시 과정을 동기화했습니다.

1. **리프레시 잠금 (`isRefreshing`)**: 이미 리프레시 요청이 진행 중이면 추가적인 리프레시 요청을 막습니다.
2. **요청 대기열 (`failedQueue`)**: 리프레시가 완료될 때까지 발생하는 모든 401 에러 요청들을 큐에 저장합니다.
3. **일괄 재시도**: 리프레시 성공 시 큐에 쌓인 모든 요청을 새로운 세션 상태로 일괄 재실행하며, 실패 시 일괄 로그아웃 처리합니다.

```typescript
// api/index.ts
if (isRefreshing) {
  return new Promise((resolve, reject) => {
    failedQueue.push({ resolve, reject });
  })
    .then(() => api(originalRequest))
    .catch((err) => Promise.reject(err));
}
```

### 결과

인증 만료 시점에도 여러 요청이 충돌 없이 안전하게 처리되며, 사용자는 인증 갱신 과정을 인지하지 못한 채 중단 없는 서비스를 이용할 수 있게 되었습니다.

---

## 14. 비로그인 무한 로딩 및 불필요한 API 호출 최적화

### 문제 상황

1. **무한 로딩 (Infinite Loading)**: 비로그인 상태로 홈페이지 접속 시, `useUser` 훅이 401(Unauthorized) 응답을 받았음에도 불구하고 API 인터셉터가 이를 '토큰 만료'로 오해하여 `/api/auth/refresh`를 호출하고, 리프레시마저 실패하면 다시 `useUser`를 재시도하는 무한 루프에 빠져 화면이 로딩 상태에서 멈춤.
2. **불필요한 API 요청**: 검색 페이지(`SearchPage`) 진입 시, 비로그인 상태임에도 `useWishlist`, `useTimetable`, `useSubscriptions` 훅이 실행되어 401 에러 로그가 콘솔에 다수 찍히고 불필요한 네트워크 트래픽 발생.

### 해결책

1. **재시도 방지 및 에러 핸들링 간소화**:
   - `useUser` 훅의 `retry` 옵션을 `false`로 설정하여 첫 실패 시 즉시 종료되도록 수정.
   - `queryFn` 내부에서 401 에러를 catch하여 `null`을 반환하도록 로직을 변경, 에러 상태가 아닌 '비로그인(Guest)' 상태로 정상 처리되도록 함.

   ```typescript
   // hooks/useUser.ts
   queryFn: async () => {
     try {
       const response = await userApi.getMyProfile();
       return response.data;
     } catch (error) {
       // 401은 에러가 아닌 게스트 상태로 간주
       if (isAxiosError(error) && error.response?.status === 401) {
         return null;
       }
       throw error;
     }
   };
   ```

2. **인터셉터 재귀 호출 차단**:
   - API 응답 인터셉터에서 401 에러 발생 시, 만약 요청 URL이 `/api/auth/refresh`라면 더 이상 재시도하지 않고 에러를 반환하도록 예외 처리 추가.

3. **조건부 훅 실행 (Enabled Option)**:
   - 개인화 데이터(찜, 구독, 시간표)를 가져오는 모든 Hook에 `enabled: !!user` 옵션을 추가하여, 유저 정보가 로드된 상태에서만 API를 호출하도록 변경.

### 결과

- 비로그인 사용자가 접속 시 즉각적으로 랜딩 페이지가 렌더링되며, 불필요한 에러 로그나 네트워크 요청 없이 쾌적한 탐색 경험을 제공하게 되었습니다.

---

## 15. 설정 페이지 이메일 변경 시 400 에러 (Unverified Email)

### 문제 상황

설정 페이지에서 '알림 이메일 주소'를 변경하고 저장 버튼을 누르면 `400 Bad Request` 에러(메시지: `UNVERIFIED_EMAIL`)가 발생하며 저장이 불가능한 현상이 발생했습니다. 이는 백엔드에서 보안을 위해 "변경된 이메일은 반드시 인증을 거쳐야 한다"는 제약 조건을 추가했으나, 프론트엔드 UI에는 인증 절차가 누락되어 있었기 때문입니다.

### 해결책

1. **인증 UI 구현**: 설정 페이지 내 이메일 입력 필드 옆에 '인증' 버튼을 추가하고, 인증 코드 발송 및 검증 로직(타이머, 코드 입력창)을 구현했습니다.
2. **상태 관리**: `verified`, `emailSent` 등의 상태를 추가하여, 사용자가 이메일을 변경하면 `verified`를 `false`로 초기화하고, 인증 완료 시에만 `true`로 변경하도록 했습니다.
3. **유효성 검사**: 저장(`onSubmit`) 시, 이메일이 변경되었는데 `verified`가 `false`라면 저장을 막고 "인증을 완료해주세요"라는 토스트 메시지를 띄우도록 방어 코드를 작성했습니다.

### 결과

사용자는 앱 내에서 원활하게 이메일 본인 인증을 수행할 수 있게 되었으며, 인증된 안전한 이메일로만 알림 설정을 저장할 수 있게 되었습니다.

---

## 16. 설정 페이지 네비게이션 바 누락 (Layout Mismatch)

### 문제 상황

메인 페이지(`HomePage`)에는 네비게이션 바(`Header`)가 포함되어 있었으나, 설정 페이지(`SettingsPage`)로 이동하면 헤더가 사라져 사용자가 메인으로 돌아갈 방법이 없는 갇힌(Trapped) UX 문제가 발생했습니다.

### 해결책

1. **전역 레이아웃 적용**: `Header` 컴포넌트를 특정 페이지(`Embed in Page`) 방식에서 전역 레이아웃(`layout.tsx`) 방식으로 변경하여, 설정 페이지를 포함한 모든 페이지에서 헤더가 유지되도록 수정했습니다.
2. **조건부 렌더링**: 온보딩 페이지(`/onboarding`) 등 헤더가 불필요한 경로에서는 `usePathname`을 사용하여 헤더를 숨기도록 처리했습니다.
3. **뒤로가기 버튼**: 설정 페이지 상단에 명시적인 '뒤로가기(←)' 버튼을 추가하여 모바일 환경 등에서의 네비게이션 편의성을 보강했습니다.

### 결과

어떤 페이지에 있더라도 일관된 네비게이션 경험을 제공하게 되었으며, 사용자는 자유롭게 메뉴 간 이동이 가능해졌습니다.
