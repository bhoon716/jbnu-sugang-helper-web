# 웹 프론트엔드 트러블슈팅 기록 (Web Troubleshooting)

이 문서는 `web` 모듈 개발 중 발생한 문제와 기술적 해결책을 기록합니다.

---

## 1. Docker 환경에서의 Radix UI 모듈 인식 오류

### 문제 상황

Docker 환경에서 `next dev` 실행 시, `package.json`에 명시된 `@radix-ui/react-alert-dialog`, `@radix-ui/react-tabs` 등의 모듈을 찾을 수 없다는 `Module not found` 에러가 발생하며 빌드가 중단되었습니다. 로컬 환경에서는 정상 작동하나 컨테이너 내부의 `node_modules`에만 특정 패키지가 누락되는 현상이 반복되었습니다.

### 원인

1. **볼륨 마운트 충돌**: 로컬의 `node_modules`와 컨테이너 내의 `node_modules`가 도커 익명 볼륨 설정에 의해 꼬일 수 있음.
2. **Lockfile 불일치**: `package-lock.json`의 변경 사항이 컨테이너 빌드 시점에 완전히 반영되지 않거나 캐시된 이미지를 사용하여 구버전 의존성이 유지됨.

### 해결책

1. **수동 모듈 주입**: 가동 중인 컨테이너 내에서 `docker exec`를 통해 누락된 패키지를 강제로 재설치하여 런타임 오류를 즉시 해결.
   - `docker exec sugang-helper-web npm install @radix-ui/react-alert-dialog @radix-ui/react-tabs`
2. **의존성 잠금 동기화**: 로컬에서 `npm install`을 새로 수행하여 `package-lock.json`을 갱신하고, 이를 Docker 빌드 시 `npm ci` 과정에서 사용하도록 구성.
3. **볼륨 대피(Exclusion)**: `docker-compose.yml`에서 `/app/node_modules`를 익명 볼륨으로 처리하여 컨테이너 내의 패키지가 로컬 환경에 덮어씌워지지 않도록 설정.

### 결과

모든 UI 컴포넌트(`Alert`, `Tabs`, `Switch` 등)가 Turbopack 환경에서 정상적으로 컴파일되고 렌더링됨을 확인했습니다.

---

## 2. API 응답 필드 불일치 (Course/Subscription)

### 문제 상황

백엔드에서 내려오는 데이터 필드명(예: `professor`)과 프론트엔트 인터페이스(`professorName`)가 일치하지 않아 데이터가 `NaN`으로 표시되거나 목록이 비어 보이는 현상이 발생했습니다.

### 해결책

- **규격 통일**: 자체 정의한 **OpenAPI v0** 사양을 기준으로 백엔드 DTO와 프론트엔드 `types/api.ts`를 전면 재매핑했습니다.
- **주요 수정**: `totalSeats`, `currentSeats`, `availableSeats`, `professorName` 등으로 모든 필드명을 표준화했습니다.

### 결과

검색 결과 및 구독 목록에서 강의명, 교수명, 수강 인원 현황이 정확하게 노출됩니다.

---

## 3. 초기 검색 상태 오인 및 로딩 피드백 부재

### 문제 상황

1. **초기 상태 오인**: 검색 페이지 진입 시 검색 조건이 비어있어(`{}`) 아무런 데이터가 뜨지 않았고, 사용자는 이를 "버튼이 동작하지 않음"으로 오인했습니다.
2. **피드백 부재**: 검색 버튼 클릭 시 로딩 표시가 없어 네트워크 지연 시 사용자가 중복 클릭하거나 멈춘 것으로 판단했습니다.

### 해결책

1. **기본값 설정**: `SearchPage`의 초기 상태를 `2026-1학기`로 설정하여 진입 즉시 데이터가 노출되도록 수정했습니다.
2. **스켈레톤 UI 도입**: 데이터 로딩 중 빈 화면 대신 테이블 형태의 **Skeleton Loader**를 보여주어 로딩 중임을 명확히 인지시켰습니다.
3. **버튼 상태 관리**: API 요청 중에는 검색 버튼 내부에 스피너를 표시하고 클릭을 방지(`disabled`)했습니다.

### 결과

사용자가 페이지 진입 시점부터 검색 완료 시점까지 끊김 없는(Seamless) 경험을 하게 되었으며, "고장"이라는 오인을 원천 차단했습니다.

### 4. 테이블 헤더 고정 (Sticky Header) 이슈

- **문제**: `shadcn/ui`의 `Table` 컴포넌트 사용 시, 내부적으로 감싸고 있는 `div`의 `overflow-x-auto` 속성 때문에 `sticky` 포지셔닝이 스크롤 컨테이너 기준이 아닌 내부 div 기준으로 잡혀 헤더가 고정되지 않는 현상 발생.
- **해결**: `CourseTable` 컴포넌트에서 `Table` 래퍼 컴포넌트 대신 표준 HTML `table` 태그를 직접 사용하고, 외부 스크롤 컨테이너(`max-h-[650px]`)에 맞춰 `sticky`가 동작하도록 구조를 변경함.

---

## 5. 검색 경험(UX) 최적화: 조건부 필터 및 자동 접힘

### 문제 상황

1. 상세 검색 필터의 항목이 많아져 실제 검색 결과 리스트가 화면 하단으로 밀려나 가독성이 저하되었습니다.
2. 교양 관련 검색 필터가 전공 검색 시에도 노출되어 혼란을 야기했습니다.

### 해결책

1. **조건부 렌더링**: 이수구분이 '교양'인 경우에만 교양 상세 카테고리 필터가 애니메이션과 함께 나타나도록 수정했습니다.
2. **자동 접힘(Auto-Collapse)**: 검색 버튼을 누르거나 엔터 키를 입력하여 검색이 시작되면 자동적으로 `Collapsible` 필터바가 닫히도록 로직을 추가하여 결과 화면이 즉시 상단에 노출되도록 했습니다.

### 결과

모바일 및 데스크톱 환경 모두에서 화면 공간을 효율적으로 사용하게 되었으며, 사용자의 검색 흐름(Flow)이 비약적으로 매끄러워졌습니다.

---

## 6. 서비스 워커 무한 로딩 및 타임아웃 처리

### 문제 상황

웹푸시 기기 등록 시, `navigator.serviceWorker.ready`가 promise 상태에서 영원히 대기하여 UI가 무한 로딩("등록 중...") 상태에 빠지는 현상이 간헐적으로 발생했습니다.

### 원인

서비스 워커 등록이 어떤 이유로 지연되거나 이미 등록된 워커가 비정상 상태일 때, ready 속성이 resolve 되지 않는 경우가 있었습니다.

### 해결책

- **Time-out 도입**: `Promise.race`를 사용하여 서비스 워커 준비에 5초의 타임아웃을 걸었습니다.
- **Fail-safe**: 5초 내에 응답이 없으면 명확한 에러를 발생시키고 UI 로딩을 해제하여 사용자가 재시도를 할 수 있도록 유도했습니다.

```typescript
// webpush.ts
const registration = await Promise.race([
  navigator.serviceWorker.ready,
  new Promise((_, reject) =>
    setTimeout(() => reject(new Error("Timeout")), 5000),
  ),
]);
```

### 결과

무한 대기 상황이 사라지고, 사용자에게 즉각적인 피드백(성공/실패)을 제공하게 되었습니다.

---

## 7. Web Push VAPID 키 환경 변수 연동

### 문제 상황

웹푸시 구독(`pushManager.subscribe`) 시점에 `applicationServerKey`가 유효하지 않다는 에러가 발생하거나 구독 객체가 `null`로 반환되었습니다.

### 원인

Next.js 환경에서 클라이언트 사이드 코드(브라우저)는 `NEXT_PUBLIC_` 접두사가 붙은 환경 변수만 접근할 수 있는데, `.env` 파일에 접두사 없이 정의하거나 `process.env` 접근이 누락되어 키 값이 `undefined`로 전달되었습니다.

### 해결책

- **변수명 변경**: `.env` 파일의 변수명을 `NEXT_PUBLIC_VAPID_KEY`로 수정했습니다.
- **유효성 검사**: `webpush.ts` 유틸리티에서 키가 존재하는지 검사하는 방어 코드를 추가하여, 키 누락 시 명확한 에러 메시지를 던지도록 수정했습니다.

### 결과

서버와 동일한 공개 키를 사용하여 VAPID 핸드셰이크가 정상적으로 이루어지게 되었습니다.

---

## 8. 포그라운드 알림 미표시 (이중 알림 구조)

### 문제 상황

브라우저 탭을 보고 있는 상태(Foreground)에서는 OS 정책이나 브라우저 설정에 따라 시스템 푸시 알림이 뜨지 않아, 사용자가 중요 알림을 놓칠 가능성이 있었습니다.

### 해결책

서비스 워커와 클라이언트 간의 **양방향 통신(Message Passing)**을 활용한 이중 알림 구조를 구축했습니다.

1. **Service Worker**: 푸시 수신 시 `showNotification`을 호출함과 동시에, 열려 있는 모든 Window Client에게 `postMessage`로 푸시 내용을 전송합니다.
2. **Client**: `navigator.serviceWorker`의 메시지 이벤트를 리스닝하고 있다가, 푸시 메시지가 오면 **`sonner` Toast**를 화면 상단에 띄웁니다.
3. **UX 강화**: `requireInteraction: true` 옵션을 추가하여 사용자가 닫기 전까지 시스템 알림이 유지되도록 설정했습니다.

### 결과

## 사용자가 다른 작업을 하거나 탭을 보고 있을 때 등 모든 시나리오에서 알림을 확실히 인지할 수 있게 되었습니다.

## 9. API 요청 중복 제거 (Request Deduplication) 및 프로미스 캐싱

### 문제 상황

로그인 후 또는 페이지 진입 시 `/api/v1/users/me` API가 짧은 간격으로 2번 이상 호출되는 현상이 발생했습니다. 이는 React Strict Mode의 영향과 더불어, Zustand의 세션 체크와 React Query의 데이터 페칭이 각각 독립적으로 발생하며 네트워크 자원을 낭비하는 결과를 초래했습니다.

### 해결책

API 레이어(`lib/api/user.ts`)에서 **Promise Caching** 패턴을 도입하여 짧은 시간 내 발생하는 동일 요청을 하나로 묶었습니다.

```typescript
let profilePromise: Promise<CommonResponse<User>> | null = null;

export const getMyProfile = async () => {
  if (profilePromise) return profilePromise; // 가고 있는 기차가 있으면 그 티켓을 같이 씀

  profilePromise = (async () => {
    try {
      const { data } = await api.get("/api/v1/users/me");
      return data;
    } finally {
      setTimeout(() => {
        profilePromise = null;
      }, 100); // 처리 완료 후 캐시 해제
    }
  })();
  return profilePromise;
};
```

### 결과

서로 다른 상태 관리 도구(Zustand, React Query)가 동일한 API를 호출하더라도 실제 네트워크 요청은 단 1회만 발생하게 되어 초기 로딩 성능이 개선되고 서버 부하를 줄였습니다.

---

---

## 10. BFF 환경에서의 자동 토큰 리프레시 인터셉터 도입

### 문제 상황

BFF 아키텍처 전환 이후 세션 쿠키를 사용함에도 불구하고, 내부적으로 관리되는 JWT 액세스 토큰이 만료되면 401 Unauthorized 에러가 발생하여 사용자가 로그아웃되는 현상이 남아있었습니다. 기존에는 단순히 로그인 페이지로 리다이렉트했으나, 이는 사용자의 작업 흐름을 끊는 요인이 되었습니다.

### 해결책

Axios 인터셉터를 고도화하여 **투명한 토큰 리프레시(Transparent Token Refresh)** 메커니즘을 구현했습니다.

1. **401 감지**: API 호출 시 401 에러가 발생하면 인터셉터가 이를 가로챕니다.
2. **자동 리프레시**: 백그라운드에서 `/api/auth/refresh`를 호출하여 서버 사이드 세션과 토큰을 갱신합니다.
3. **요청 재시도**: 리프레시 성공 시 기존의 `failedQueue`에 담겨있던 요청들을 새로운 세션 상태로 자동 재시도합니다.
4. **무한 루프 방지**: `_retry` 플래그와 `isRefreshing` 상태를 활용하여 리프레시 요청 자체가 무한 반복되는 것을 원천 차단했습니다.

### 결과

사용자는 서비스 이용 중 별도의 재로그인 과정 없이도 장시간 안정적인 인증 상태를 유지할 수 있게 되었습니다.

---

## 12. 프리미엄 대시보드 Bento Grid 도입 및 레이아웃 최적화

### 문제 상황

기존 대시보드는 여러 독립된 섹션(시간표, 관심 강의, 알림)이 단순히 나열되어 있어 시각적 집중도가 떨어지고, 특히 모바일/작은 해상도에서 정보 과다로 인한 피로도가 높았습니다.

### 해결책

1. **Bento Grid 시스템**: 현대적이고 세련된 그리드 레이아웃을 적용하여 정보의 우선순위에 따라 구획을 나눴습니다.
2. **레이아웃 간소화 (Layout Simplification)**: 사용자가 가장 핵심적인 정보인 '시간표'에 집중할 수 있도록, 기존 우측 컬럼의 '관심 강의'와 '실시간 알림' 목록을 상세 목록 형태에서 제외하고 `DashboardStats` 위젯으로 요약 정보만 상단에 노출했습니다.
3. **영역 확장**: 목록 섹션이 제거된 공간에 '대표 시간표' 섹션을 전면(Full-width)으로 확장하여 시각적 몰입감을 극대화했습니다.

### 결과

불필요한 데이터 로딩과 UI 요소를 줄임으로써 대시보드 진입 속도가 향상되었으며, 사용자는 가장 중요한 주간 일정을 더 크고 명확하게 확인할 수 있게 되었습니다.

---

## 13. 401 인터셉터 정교화 (Promise Queueing & Retry Logic)

### 문제 상황

BFF 환경에서 여러 API가 동시에 호출되는 중 액세스 토큰이 만료될 경우, 각 요청마다 독립적으로 401 에러를 받고 여러 번의 리프레시 시도가 발생하거나, 리프레시 도중 발생한 요청들이 유실되는 현상이 발견되었습니다.

### 해결책

Axios 인터셉터에 **요청 큐(Request Queue)** 메커니즘을 도입하여 리프레시 과정을 동기화했습니다.

1. **리프레시 잠금 (`isRefreshing`)**: 이미 리프레시 요청이 진행 중이면 추가적인 리프레시 요청을 막습니다.
2. **요청 대기열 (`failedQueue`)**: 리프레시가 완료될 때까지 발생하는 모든 401 에러 요청들을 큐에 저장합니다.
3. **일괄 재시도**: 리프레시 성공 시 큐에 쌓인 모든 요청을 새로운 세션 상태로 일괄 재실행하며, 실패 시 일괄 로그아웃 처리합니다.

```typescript
// api/index.ts
if (isRefreshing) {
  return new Promise((resolve, reject) => {
    failedQueue.push({ resolve, reject });
  })
    .then(() => api(originalRequest))
    .catch((err) => Promise.reject(err));
}
```

### 결과

인증 만료 시점에도 여러 요청이 충돌 없이 안전하게 처리되며, 사용자는 인증 갱신 과정을 인지하지 못한 채 중단 없는 서비스를 이용할 수 있게 되었습니다.

---

## 14. 비로그인 무한 로딩 및 불필요한 API 호출 최적화

### 문제 상황

1. **무한 로딩 (Infinite Loading)**: 비로그인 상태로 홈페이지 접속 시, `useUser` 훅이 401(Unauthorized) 응답을 받았음에도 불구하고 API 인터셉터가 이를 '토큰 만료'로 오해하여 `/api/auth/refresh`를 호출하고, 리프레시마저 실패하면 다시 `useUser`를 재시도하는 무한 루프에 빠져 화면이 로딩 상태에서 멈춤.
2. **불필요한 API 요청**: 검색 페이지(`SearchPage`) 진입 시, 비로그인 상태임에도 `useWishlist`, `useTimetable`, `useSubscriptions` 훅이 실행되어 401 에러 로그가 콘솔에 다수 찍히고 불필요한 네트워크 트래픽 발생.

### 해결책

1. **재시도 방지 및 에러 핸들링 간소화**:
   - `useUser` 훅의 `retry` 옵션을 `false`로 설정하여 첫 실패 시 즉시 종료되도록 수정.
   - `queryFn` 내부에서 401 에러를 catch하여 `null`을 반환하도록 로직을 변경, 에러 상태가 아닌 '비로그인(Guest)' 상태로 정상 처리되도록 함.

   ```typescript
   // hooks/useUser.ts
   queryFn: async () => {
     try {
       const response = await userApi.getMyProfile();
       return response.data;
     } catch (error) {
       // 401은 에러가 아닌 게스트 상태로 간주
       if (isAxiosError(error) && error.response?.status === 401) {
         return null;
       }
       throw error;
     }
   };
   ```

2. **인터셉터 재귀 호출 차단**:
   - API 응답 인터셉터에서 401 에러 발생 시, 만약 요청 URL이 `/api/auth/refresh`라면 더 이상 재시도하지 않고 에러를 반환하도록 예외 처리 추가.

3. **조건부 훅 실행 (Enabled Option)**:
   - 개인화 데이터(찜, 구독, 시간표)를 가져오는 모든 Hook에 `enabled: !!user` 옵션을 추가하여, 유저 정보가 로드된 상태에서만 API를 호출하도록 변경.

### 결과

- 비로그인 사용자가 접속 시 즉각적으로 랜딩 페이지가 렌더링되며, 불필요한 에러 로그나 네트워크 요청 없이 쾌적한 탐색 경험을 제공하게 되었습니다.

---

## 15. 설정 페이지 이메일 변경 시 400 에러 (Unverified Email)

### 문제 상황

설정 페이지에서 '알림 이메일 주소'를 변경하고 저장 버튼을 누르면 `400 Bad Request` 에러(메시지: `UNVERIFIED_EMAIL`)가 발생하며 저장이 불가능한 현상이 발생했습니다. 이는 백엔드에서 보안을 위해 "변경된 이메일은 반드시 인증을 거쳐야 한다"는 제약 조건을 추가했으나, 프론트엔드 UI에는 인증 절차가 누락되어 있었기 때문입니다.

### 해결책

1. **인증 UI 구현**: 설정 페이지 내 이메일 입력 필드 옆에 '인증' 버튼을 추가하고, 인증 코드 발송 및 검증 로직(타이머, 코드 입력창)을 구현했습니다.
2. **상태 관리**: `verified`, `emailSent` 등의 상태를 추가하여, 사용자가 이메일을 변경하면 `verified`를 `false`로 초기화하고, 인증 완료 시에만 `true`로 변경하도록 했습니다.
3. **유효성 검사**: 저장(`onSubmit`) 시, 이메일이 변경되었는데 `verified`가 `false`라면 저장을 막고 "인증을 완료해주세요"라는 토스트 메시지를 띄우도록 방어 코드를 작성했습니다.

### 결과

사용자는 앱 내에서 원활하게 이메일 본인 인증을 수행할 수 있게 되었으며, 인증된 안전한 이메일로만 알림 설정을 저장할 수 있게 되었습니다.

---

## 16. 설정 페이지 네비게이션 바 누락 (Layout Mismatch)

### 문제 상황

메인 페이지(`HomePage`)에는 네비게이션 바(`Header`)가 포함되어 있었으나, 설정 페이지(`SettingsPage`)로 이동하면 헤더가 사라져 사용자가 메인으로 돌아갈 방법이 없는 갇힌(Trapped) UX 문제가 발생했습니다.

### 해결책

1. **전역 레이아웃 적용**: `Header` 컴포넌트를 특정 페이지(`Embed in Page`) 방식에서 전역 레이아웃(`layout.tsx`) 방식으로 변경하여, 설정 페이지를 포함한 모든 페이지에서 헤더가 유지되도록 수정했습니다.
2. **조건부 렌더링**: 온보딩 페이지(`/onboarding`) 등 헤더가 불필요한 경로에서는 `usePathname`을 사용하여 헤더를 숨기도록 처리했습니다.
3. **뒤로가기 버튼**: 설정 페이지 상단에 명시적인 '뒤로가기(←)' 버튼을 추가하여 모바일 환경 등에서의 네비게이션 편의성을 보강했습니다.

### 결과

어떤 페이지에 있더라도 일관된 네비게이션 경험을 제공하게 되었으며, 사용자는 자유롭게 메뉴 간 이동이 가능해졌습니다.

---

## 17. 네비게이션 바 중복 노출 (Double Header) 및 UI 간소화

### 문제 상황

1. **Double Header**: 전역 레이아웃(`layout.tsx`)에 `Header` 컴포넌트를 통합했음에도 불구하고, `SearchPage`, `NotificationPage`, `TimetablePage`, `CourseDetailPage` 등 각 페이지 내부에서도 `<Header />`를 호출하고 있어 네비게이션 바가 2개씩 표시되는 UI 버그가 발생했습니다.
2. **UI Clutter**: 모바일 환경에서 "총 N개의 강의 검색됨"이라는 텍스트가 화면 공간을 차지하여, 실제 수강신청에 필요한 버튼이나 정보가 가려지는 불편함이 있었습니다.

### 해결책

1. **중복 컴포넌트 제거**: 각 페이지(`app/*/page.tsx`) 파일에서 `<Header />` 컴포넌트 import 및 JSX 렌더링 코드를 모두 제거하여, `layout.tsx`에서 제공하는 단일 헤더만 보이도록 수정했습니다.
2. **UI 요소 제거**: 사용자 피드백을 수용하여, 검색 결과 상단의 "총 N개의 강의 검색됨" 카운터 표시 블록을 삭제하여 UI를 더 깔끔하게 만들었습니다.

### 결과

- 모든 페이지에서 일관된 단일 네비게이션 경험을 제공하게 되었습니다.

---

## 18. 시간표 렌더링 초기화 이슈 (Empty Timetable)

### 문제 상황

시간표 페이지(`/timetable`) 진입 시, `useQuery`로 데이터를 받아왔음에도 불구하고 화면에 시간표가 표시되지 않고 "아직 생성된 시간표가 없습니다" 메시지도 뜨지 않는 빈 상태가 지속되었습니다.

### 원인

React의 렌더링 사이클과 State 초기화 시점의 불일치가 원인이었습니다.
기존 코드에서는 `selectedTimetableId`를 설정하는 로직이 컴포넌트 본문(Render Body)에 조건문으로 작성되어 있었는데, 이는 React의 순수성(Purity) 원칙에 어긋나며, 데이터가 `useQuery`로부터 도착한 직후 리렌더링이 발생할 때 상태 업데이트가 누락되거나 무시되는 경우가 발생했습니다.

### 해결책

1. **Side Effect 분리**: 상태 초기화 로직을 `useEffect` 내부로 이동하여, `timetables` 데이터가 변경될 때만 명시적으로 실행되도록 수정했습니다.
2. **로딩 상태 시각화**: 상세 시간표 데이터를 가져오는 동안(`isDetailLoading`) 로딩 스피너를 표시하여 사용자에게 진행 상황을 명확히 알렸습니다.

```typescript
// Before
if (timetables.length > 0 && selectedTimetableId === null) {
  setSelectedTimetableId(timetables[0].id);
}

// After
useEffect(() => {
  if (timetables.length > 0 && selectedTimetableId === null) {
    setSelectedTimetableId(timetables[0].id);
  }
}, [timetables, selectedTimetableId]);
```

### 결과

페이지 진입 시 첫 번째(또는 대표) 시간표가 즉시 선택되어 정상적으로 렌더링됩니다.

---

## 19. 모바일 환경에서의 시간표 그리드 시인성 저하

### 문제 상황

모바일 기기의 좁은 화면 폭으로 인해 7일치 시간표 열이 지나치게 좁게 렌더링되어, 수업명과 시간 등의 텍스트가 겹치거나 생략되어 읽을 수 없는 현상이 발생했습니다.

### 해결책

1. **최소 너비 강제**: 그리드 컨테이너에 `min-w-[600px]`를 부여하여 열 너비의 하한선을 확보했습니다.
2. **가로 스크롤 도입**: 고정된 너비로 인해 화면을 벗어나는 영역은 가로 스크롤(`overflow-x-auto`)을 통해 탐색할 수 있도록 UX를 개선했습니다.
3. **폰트 스케일업**: 모바일 환경을 고려하여 그리드 내부 텍스트(`text-[10px]` -> `text-xs`)의 크기를 키우고 가독성을 보완했습니다.

### 결과

사용자는 모바일에서도 텍스트 뭉개짐 없이 쾌적하게 시간표 정보를 인지할 수 있게 되었습니다.

---

## 20. 모바일 가로 스크롤 시 이미지 저장 짤림 현상

### 문제 상황

`html-to-image` 라이브러리를 사용하여 시간표를 캡처할 때, 브라우저의 가로 스크롤로 인해 화면에 보이지 않는 영역(오른쪽 요일 등)이 이미지에서 잘려서 저장되는 문제가 발생했습니다.

### 원인

라이브러리가 기본적으로 요소의 가시적인 `getBoundingClientRect` 크기를 기준으로 캡처를 시도하기 때문에, 스크롤 컨테이너 내부에 숨겨진 영역이 포함되지 않았습니다.

### 해결책

1. **실제 크기 계산**: 타겟 요소의 `scrollWidth`와 `scrollHeight`를 직접 계산하여 캡처 옵션의 `width`, `height`로 명시적으로 전달했습니다.
2. **패딩 보정**: 캡처 시 추가되는 여백(Padding) 값을 너비/높이 계산에 정확히 반영하여 패딩으로 인해 내용물이 밀려나는 현상을 방지했습니다.
3. **레이아웃 초기화**: 캡처 순간에만 `maxWidth: none`, `minWidth: none` 스타일을 강제 적용하여 브라우저의 레이아웃 제약을 완전히 해제했습니다.

### 결과

## 사용자가 현재 보고 있는 화면 상태와 상관없이, 항상 전체 요일이 포함된 깔끔하고 선명한(2x 해상도) 시간표 이미지를 저장할 수 있게 되었습니다.

## 21. 이벤트 핸들러 내 Hook 호출로 인한 Invalid Hook Call

### 문제 상황

`CourseSearchBar` 컴포넌트의 체크박스 `onClick` 이벤트 핸들러 내에서 유저 정보를 가져오기 위해 `useUser` 훅을 호출했을 때, "Invalid hook call. Hooks can only be called inside of the body of a function component" 에러가 발생하며 앱이 중단되었습니다.

### 원인

React의 **Hooks 규칙(Rules of Hooks)**에 따라 훅은 반드시 리액트 함수 컴포넌트의 최상위(Top-level)에서만 호출되어야 합니다. `onClick`과 같은 이벤트 핸들러나 일반 자바스크립트 함수 내부에서 훅을 호출하는 것은 금지되어 있습니다.

### 해결책

1. **호출 위치 변경**: 핸들러 내부에 있던 `useUser` 호출을 컴포넌트 본문 상단으로 이동시켰습니다.
2. **데이터 활용**: 상단에서 가져온 `user` 데이터를 핸들러 함수 내에서 참조하여 비로그인 여부를 판단하도록 로직을 수정했습니다.

```tsx
// 수정 후
export function CourseSearchBar(...) {
  const { data: user } = useUser(); // 최상위 호출

  const handleWishlistToggle = () => {
    if (!user) { // 데이터 참조
      toast.error("로그인이 필요합니다.");
      return;
    }
    // ... logic
  };
}
```

### 결과

## 리액트 렌더링 생명주기에 부합하는 올바른 훅 사용 방식을 통해 런타임 에러를 해결하고 안정적인 인증 체크 로직을 구현했습니다.

## 22. 인앱 브라우저 Google 로그인 차단 및 감지 이슈

### 문제 상황

에브리타임, 카카오톡, 페이스북 등의 앱 내부 브라우저에서 Google 로그인을 시도할 경우, Google의 보안 정책(`disallowed_useragent`)에 의해 로그인이 차단되는 현상이 발생했습니다.

### 원인

Google은 임베디드 웹뷰(WebView)에서의 OAuth 요청을 보안상의 이유로 허용하지 않습니다. 특히 User-Agent에 `Whale`이 포함되거나 특정 앱의 식별자가 포함된 경우 비정상적인 브라우저로 판단될 수 있습니다.

### 해결책

1. **정교한 감지 로직**: `lib/utils.ts`의 `isInAppBrowser` 함수를 강화하여 `Everytime`, `KAKAOTALK`, `FB_IAB`, `Instagram` 등을 감지하도록 개선했습니다.
2. **Whale 예외 처리**: 네이버 웨일 브라우저의 경우 정상적인 브라우저임에도 문자열 패턴에 의해 인앱으로 오판되는 경우가 있어, 명시적으로 제외(`!/Whale/i.test(ua)`) 처리를 추가했습니다.
3. **UX 개선**: 인앱 브라우저 감지 시 사용자에게 외부 브라우저(Chrome, Safari 등) 사용을 권장하는 안내 문구를 노출하고, 그럼에도 불구하고 진행을 원하는 사용자를 위해 **"그래도 계속하기"** 옵션을 제공하여 유연성을 확보했습니다.

### 결과

모바일 앱을 통해 유입되는 사용자들이 로그인 실패 원인을 명확히 인지하고, 성공적으로 로그인을 완료할 수 있는 경로를 제공하게 되었습니다.

---

## 23. 로컬 개발 환경에서의 API_URL Rewrite 설정 오류

### 문제 상황

`web/.env` 파일의 `NEXT_PUBLIC_API_URL` 설정을 잘못 구성하여 Next.js의 `rewrites` 기능이 동작하지 않거나 API 호출이 실패하는 문제가 발생했습니다.

### 원인

`next.config.ts`에서 `/api/:path*`를 백엔드로 프록시할 때, `.env`에 정의된 URL 형식이나 프로토콜이 실제 백엔드 주소와 일치하지 않아 발생한 연결 오류였습니다.

### 해결책

1. **환경 변수 가이드**: `.env` 설정 시 실제 백엔드 주소(예: `http://localhost:8080`)를 정확히 입력하도록 문서를 보강했습니다.
2. **Rewrite 규칙 명확화**: `next.config.ts`의 `destination` 설정을 환경 변수 기반으로 동적으로 구성하여 유연성을 높였습니다.

### 결과

로컬 및 배포 환경에서 API 요청이 안정적으로 백엔드 서버로 전달됩니다.
